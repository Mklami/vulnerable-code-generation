import os
import json
import subprocess
from multiprocessing import Pool, cpu_count

BASE_DIR    = os.path.dirname(os.path.abspath(__file__))
OUTPUTS_DIR = os.path.join(BASE_DIR, 'llm_outputs')
EXTRACT_DIR = os.path.join(BASE_DIR, 'compilable_c_code')
REPORTS_DIR = os.path.join(BASE_DIR, 'reports')
SUMMARY_DIR = os.path.join(BASE_DIR, 'summary')

for d in (REPORTS_DIR, SUMMARY_DIR):
    os.makedirs(d, exist_ok=True)


def load_prompts_map(json_path):
    """
    Load the original prompts from the model results JSON.
    Returns a dict mapping filenames like '000.c' to prompt strings.
    """
    with open(json_path, 'r') as f:
        entries = json.load(f)
    prompts_map = {}
    for i, entry in enumerate(entries):
        fname = f"{i:03d}.c"
        prompts_map[fname] = entry.get('prompt', entry.get('input', ''))
    return prompts_map


def esbmc_worker(args):
    """Worker to run ESBMC on a single file."""
    model_name, c_dir, fname, prompts_map = args
    src = os.path.join(c_dir, fname)
    report_dir = os.path.join(REPORTS_DIR, model_name)
    os.makedirs(report_dir, exist_ok=True)
    out_txt = os.path.join(report_dir, fname.replace('.c', '.esbmc.txt'))

    cmd = ['esbmc', src, '--unwind', '0', '--timeout', '30', '--k-induction', '--incremental-bmc']
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    raw = []
    try:
        for line in proc.stdout:
            raw.append(line)
        proc.wait(timeout=300)
    except subprocess.TimeoutExpired:
        proc.kill()

    raw_text = ''.join(raw)
    with open(out_txt, 'w') as f:
        f.write(raw_text)

    # parse ESBMC result
    status = 'UNKNOWN'
    if any('ERROR: Timed out' in l for l in raw):
        status = 'ERROR: Timed out'
    elif any('ERROR: PARSING ERROR' in l for l in raw):
        status = 'ERROR: PARSING ERROR'
    elif any('VERIFICATION FAILED' in l for l in raw):
        status = 'VERIFICATION FAILED'
    elif any('VERIFICATION SUCCESSFUL' in l for l in raw):
        status = 'VERIFICATION SUCCESSFUL'

    violated = None
    if status == 'VERIFICATION FAILED':
        for i, line in enumerate(raw):
            if 'Violated property:' in line:
                violated = raw[i+2].strip() if i+2 < len(raw) else None
                break

    return fname, {
        'prompt': prompts_map.get(fname, ''),
        'esbmc_output': status,
        'violated_property': violated
    }


def analyze_with_esbmc(model_name, c_dir, prompts_map):
    """Parallel ESBMC analysis."""
    c_files = [f for f in os.listdir(c_dir) if f.endswith('.c')]
    pool_size = min(cpu_count(), len(c_files))
    args = [(model_name, c_dir, f, prompts_map) for f in c_files]

    summary = {}
    with Pool(pool_size) as pool:
        for fname, result in pool.imap_unordered(esbmc_worker, args):
            summary[fname] = result
            print(f"[analyze] {result['esbmc_output']} for {fname}")

    summary_path = os.path.join(SUMMARY_DIR, f"{model_name}_detailed_summary.json")
    with open(summary_path, 'w') as f:
        json.dump(summary, f, indent=2)
    print(f"[analyze] Detailed summary at {summary_path}")


def main():
    print("[main] Starting ESBMC analysis only")
    result_files = [fn for fn in os.listdir(OUTPUTS_DIR) if fn.endswith('_results.json')]
    for fn in result_files:
        model = fn[:-len('_results.json')]
        print(f"[main] === Model: {model} ===")
        json_path = os.path.join(OUTPUTS_DIR, fn)
        c_out_dir = os.path.join(EXTRACT_DIR, model)

        # load prompts map but skip extraction/compilation
        prompts_map = load_prompts_map(json_path)

        # run ESBMC analysis
        analyze_with_esbmc(model, c_out_dir, prompts_map)

    print("[main] All analyses complete")

if __name__ == '__main__':
    main()
