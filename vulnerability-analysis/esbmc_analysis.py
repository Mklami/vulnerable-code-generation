import os
import json
import subprocess
from multiprocessing import Pool
from collections import Counter, OrderedDict

BASE_DIR    = os.path.dirname(os.path.abspath(__file__))
OUTPUTS_DIR = os.path.join(BASE_DIR, 'llm_outputs')
EXTRACT_DIR = os.path.join(BASE_DIR, 'compilable_c_code')
REPORTS_DIR = os.path.join(BASE_DIR, 'reports')
SUMMARY_DIR = os.path.join(BASE_DIR, 'summary')

for d in (REPORTS_DIR, SUMMARY_DIR):
    os.makedirs(d, exist_ok=True)


def load_prompts_map(json_path):
    """
    Load the original prompts from the model results JSON.
    Returns a dict mapping filenames like '000.c' to prompt strings.
    """
    with open(json_path, 'r') as f:
        entries = json.load(f)
    prompts_map = {}
    for i, entry in enumerate(entries):
        fname = f"{i:03d}.c"
        prompts_map[fname] = entry.get('prompt', entry.get('input', ''))
    return prompts_map


def esbmc_worker(args):
    model_name, c_dir, fname, prompts_map = args
    src = os.path.join(c_dir, fname)
    report_dir = os.path.join(REPORTS_DIR, model_name)
    os.makedirs(report_dir, exist_ok=True)
    out_txt = os.path.join(report_dir, fname.replace('.c', '.esbmc.txt'))

    cmd = ['esbmc', src, '--unwind', '0', '--timeout', '30', '--k-induction', '--incremental-bmc']
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    raw = []
    try:
        for line in proc.stdout:
            raw.append(line)
        proc.wait(timeout=300)
    except subprocess.TimeoutExpired:
        proc.kill()

    raw_text = ''.join(raw)
    with open(out_txt, 'w') as f:
        f.write(raw_text)

    # parse ESBMC result
    status = 'UNKNOWN'
    subreason = None

    if any('ERROR: Timed out' in l for l in raw):
        status = 'ERROR: Timed out'
    elif any('ERROR: PARSING ERROR' in l for l in raw):
        status = 'ERROR: PARSING ERROR'
        # check for gets() usage in the source file
        try:
            with open(src, 'r') as sf:
                source_text = sf.read()
                if 'gets(' in source_text:
                    subreason = 'deprecated_gets'
        except Exception:
            pass
    elif any('VERIFICATION FAILED' in l for l in raw):
        status = 'VERIFICATION FAILED'
    elif any('VERIFICATION SUCCESSFUL' in l for l in raw):
        status = 'VERIFICATION SUCCESSFUL'

    violated = None
    if status == 'VERIFICATION FAILED':
        for i, line in enumerate(raw):
            if 'Violated property:' in line:
                violated = raw[i+2].strip() if i+2 < len(raw) else None
                break

    result = {
        'prompt': prompts_map.get(fname, ''),
        'esbmc_output': status,
        'violated_property': violated
    }

    if status == 'ERROR: PARSING ERROR' and subreason:
        result['parsing_error_reason'] = subreason

    return fname, result


def analyze_with_esbmc(model_name, c_dir, prompts_map):
    """Parallel ESBMC analysis."""
    c_files = [f for f in os.listdir(c_dir) if f.endswith('.c')]
    pool_size = min(8, len(c_files))
    args = [(model_name, c_dir, f, prompts_map) for f in c_files]

    summary = {}
    with Pool(pool_size) as pool:
        for fname, result in pool.imap_unordered(esbmc_worker, args):
            summary[fname] = result
            print(f"[analyze] {result['esbmc_output']} for {fname}")

    # sort summary by filename
    ordered_summary = OrderedDict(sorted(summary.items(), key=lambda x: x[0]))

    # write detailed summary
    summary_path = os.path.join(SUMMARY_DIR, f"{model_name}_detailed_summary.json")
    with open(summary_path, 'w') as f:
        json.dump(ordered_summary, f, indent=2)
    print(f"[analyze] Detailed summary at {summary_path}")

    # executive summary: count statuses
    counts = Counter()
    parsing_breakdown = Counter()

    for res in ordered_summary.values():
        status = res['esbmc_output']
        counts[status] += 1

        if status == 'ERROR: PARSING ERROR':
            reason = res.get('parsing_error_reason', 'other')
            parsing_breakdown[reason] += 1

    # Nest parsing breakdown
    status_counts = dict(counts)
    if 'ERROR: PARSING ERROR' in status_counts:
        status_counts['ERROR: PARSING ERROR'] = {
            'total': counts['ERROR: PARSING ERROR'],
            **dict(parsing_breakdown)
        }

    executive = {
        'total_files': len(ordered_summary),
        'status_counts': status_counts
    }

    exec_path = os.path.join(SUMMARY_DIR, f"{model_name}_executive_summary.json")
    with open(exec_path, 'w') as f:
        json.dump(executive, f, indent=2)
    print(f"[analyze] Executive summary at {exec_path}")


def main():
    print("[main] Starting ESBMC analysis only")
    result_files = [fn for fn in os.listdir(OUTPUTS_DIR) if fn.endswith('_results.json')]
    for fn in result_files:
        model = fn[:-len('_results.json')]
        print(f"[main] === Model: {model} ===")
        json_path = os.path.join(OUTPUTS_DIR, fn)
        c_out_dir = os.path.join(EXTRACT_DIR, model)

        # load prompts map but skip extraction/compilation
        prompts_map = load_prompts_map(json_path)

        # run ESBMC analysis
        analyze_with_esbmc(model, c_out_dir, prompts_map)

    print("[main] All analyses complete")

if __name__ == '__main__':
    main()
