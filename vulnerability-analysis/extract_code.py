import os
import json
import subprocess
import re

BASE_DIR    = os.path.dirname(os.path.abspath(__file__))
OUTPUTS_DIR = os.path.join(BASE_DIR, 'llm_outputs')
EXTRACT_DIR = os.path.join(BASE_DIR, 'compilable_c_code')

# Common headers to inject if missing
COMMON_HEADERS = [
    '<stdio.h>',
    '<stdlib.h>',
    '<string.h>',
    '<stdint.h>',
    '<stddef.h>',
    '<stdbool.h>'
]

os.makedirs(EXTRACT_DIR, exist_ok=True)

def extract_c_files(json_path, out_dir):
    """
    Extract C code blocks from <model>_results.json into .c files,
    prepend missing common headers.
    Returns a tuple (prompts_map, skipped_count, total_entries).
    """
    print(f"[extract] Loading prompts from {json_path}")
    os.makedirs(out_dir, exist_ok=True)
    with open(json_path, 'r') as f:
        entries = json.load(f)

    total_entries = len(entries)
    skipped = 0
    prompts_map = {}

    # match code fenced by triple backticks, with optional 'c'
    fence_re = re.compile(r'```(?:c)?\s*(?P<code>.*?)\s*```', re.DOTALL)

    for i, entry in enumerate(entries):
        output = entry.get('output', '')
        m = fence_re.search(output)
        if not m:
            print(f"[extract] No code fence in entry {i}; skipping")
            skipped += 1
            continue

        code_body = m.group('code').strip()

        # Determine missing headers
        missing = []
        for hdr in COMMON_HEADERS:
            include_stmt = f'#include {hdr}'
            if include_stmt not in code_body:
                missing.append(include_stmt)

        full_code = ("\n".join(missing) + "\n\n" if missing else "") + code_body + "\n"

        fname = f"{i:03d}.c"
        path = os.path.join(out_dir, fname)
        with open(path, 'w') as cf:
            cf.write(full_code)
        print(f"[extract] Wrote {path} (injected {len(missing)} headers)")

        prompts_map[fname] = entry.get('prompt', entry.get('input', ''))

    extracted = total_entries - skipped
    print(f"[extract] Extracted {extracted}/{total_entries} .c files to {out_dir}")
    return prompts_map, skipped, total_entries


def compile_c_files(c_dir):
    """
    Try to compile each .c file in c_dir with gcc -std=gnu11 -Wall.
    Returns a dict mapping filename -> (success: bool, stderr: str).
    After compilation, removes all non-.c files (binaries, etc.).
    """
    compile_results = {}

    for fname in sorted(os.listdir(c_dir)):
        if not fname.endswith('.c'):
            continue

        src_path = os.path.join(c_dir, fname)
        bin_path = os.path.join(c_dir, fname[:-2] + '.out')
        cmd = ['gcc', '-std=gnu11', '-Wall', src_path, '-o', bin_path]

        try:
            subprocess.run(
                cmd,
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            compile_results[fname] = (True, "")
        except subprocess.CalledProcessError as e:
            compile_results[fname] = (False, e.stderr)

    # Remove non-.c artifacts
    for other in os.listdir(c_dir):
        if not other.endswith('.c'):
            os.remove(os.path.join(c_dir, other))

    return compile_results


def main():
    print("[main] Starting code extraction")
    summary = []  # collect per-model stats

    result_files = [fn for fn in os.listdir(OUTPUTS_DIR) if fn.endswith('_results.json')]
    for fn in result_files:
        model = fn[:-len('_results.json')]
        print(f"[main] === Model: {model} ===")
        json_path = os.path.join(OUTPUTS_DIR, fn)
        c_out_dir = os.path.join(EXTRACT_DIR, model)

        # Extract code
        prompts_map, skipped, total = extract_c_files(json_path, c_out_dir)

        # Compile and get results
        print(f"[compile] Checking compilability in {c_out_dir}")
        comp_results = compile_c_files(c_out_dir)
        succ = sum(1 for ok, _ in comp_results.values() if ok)
        fail = len(comp_results) - succ

        # Remove sources that failed compilation
        for fname, (ok, _) in comp_results.items():
            if not ok:
                os.remove(os.path.join(c_out_dir, fname))
                print(f"[cleanup] Removed non-compilable source: {fname}")

        # Record summary
        summary.append((model, skipped, succ, fail, total))

        print(f"[compile] {succ}/{succ+fail} files compiled successfully, {fail} failed")
        print(f"[summary] Model {model}: without code: {skipped}, compilable: {succ}, non-compilable: {fail}")

    # Print overall summary
    print("[main] Extraction and compilation summary:")
    for model, skipped, succ, fail, total in summary:
        print(f"  - {model}: total entries={total}, no code={skipped}, compilable={succ}, failed={fail}")

    print("[main] All code processed.")

if __name__ == '__main__':
    main()
