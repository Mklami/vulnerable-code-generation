import os
import json
import subprocess

BASE_DIR    = os.path.dirname(os.path.abspath(__file__))
RESULTS_DIR = os.path.join(BASE_DIR, 'llm_outputs')
EXTRACT_DIR = os.path.join(BASE_DIR, 'compilable_c_code')
REPORTS_DIR = os.path.join(BASE_DIR, 'reports')
SUMMARY_DIR = os.path.join(BASE_DIR, 'summary')

for d in (EXTRACT_DIR, REPORTS_DIR, SUMMARY_DIR):
    os.makedirs(d, exist_ok=True)


def extract_c_files(json_path, out_dir):
    """
    Extract C code blocks from <model>_results.json into .c files,
    and return a mapping of filenames to the original prompts.
    """
    print(f"[extract] Loading prompts from {json_path}")
    os.makedirs(out_dir, exist_ok=True)
    with open(json_path, 'r') as f:
        entries = json.load(f)

    fence_re = __import__('re').compile(r'<code>\s*(.*?)</code>', __import__('re').DOTALL)
    prompts_map = {}
    skipped = 0
    for i, entry in enumerate(entries):
        output = entry.get('output', '')
        m = fence_re.search(output)
        if not m:
            print(f"[extract] No code fence in entry {i}; skipping")
            skipped += 1
            continue
        code = m.group(1).strip()
        fname = f"{i:03d}.c"
        path = os.path.join(out_dir, fname)
        with open(path, 'w') as cf:
            cf.write(code + '\n')
        print(f"[extract] Wrote {path}")

        # store the original prompt for this snippet
        prompts_map[fname] = entry.get('prompt', entry.get('input', ''))

    total = len(entries) - skipped
    print(f"[extract] Extracted {total}/{len(entries)} .c files to {out_dir}")
    return prompts_map


def analyze_with_esbmc(model_name, c_dir, prompts_map):
    """
    Run ESBMC unbounded + k-induction on each .c file,
    save raw output and produce a detailed summary without printing logs.
    """
    print(f"[analyze] Starting ESBMC analysis for model '{model_name}' in {c_dir}")
    report_dir = os.path.join(REPORTS_DIR, model_name)
    os.makedirs(report_dir, exist_ok=True)

    summary = {}
    c_files = sorted(f for f in os.listdir(c_dir) if f.endswith('.c'))
    for fname in c_files:
        print(f"[analyze] Processing file: {fname}")
        src = os.path.join(c_dir, fname)
        esbmc_out_path = os.path.join(report_dir, fname.replace('.c', '.esbmc.txt'))

        cmd = [
            'esbmc', src,
            '--unwind', '0',
            '--timeout', '30',
            '--k-induction',
            '--overflow-check',
            '--memory-leak-check'
        ]
        print(f"[analyze] Running: {' '.join(cmd)}")

        # Capture ESBMC output silently
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        raw_lines = []
        try:
            for line in proc.stdout:
                raw_lines.append(line)
            proc.wait(timeout=300)
        except subprocess.TimeoutExpired:
            proc.kill()
            raw_lines.append('ERROR: ESBMC timed out\n')
            print(f"[analyze] Timeout on {fname}")

        raw = ''.join(raw_lines)
        with open(esbmc_out_path, 'w') as f:
            f.write(raw)
        print(f"[analyze] ESBMC output saved to {esbmc_out_path}")

        # Extract detailed vulnerability messages
        vulnerabilities = []
        for ln in raw_lines:
            if 'failure:' in ln or ln.startswith('**'):
                vulnerabilities.append(ln.strip())

        summary[fname] = {
            'original_prompt': prompts_map.get(fname, ''),
            'vulnerabilities': vulnerabilities
        }
        print(f"[analyze] Found {len(vulnerabilities)} issue(s) in {fname}")

    summary_path = os.path.join(SUMMARY_DIR, f"{model_name}_detailed_summary.json")
    with open(summary_path, 'w') as f:
        json.dump(summary, f, indent=2)
    print(f"[analyze] Finished ESBMC analysis for {model_name}: detailed summary at {summary_path}")


def compile_c_files(c_dir):
    """
    Try to compile each .c file in c_dir with gcc -Wall -Werror.
    Returns a dict mapping filename → True/False for compile success.
    Afterwards, deletes every non-.c file in c_dir.
    """
    compile_results = {}
    for fname in sorted(os.listdir(c_dir)):
        if not fname.endswith('.c'):
            continue
        src_path = os.path.join(c_dir, fname)
        bin_path = os.path.join(c_dir, fname[:-2] + '.out')
        cmd = ['gcc', '-Wall', '-Werror', src_path, '-o', bin_path]
        try:
            subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            compile_results[fname] = True
        except subprocess.CalledProcessError as e:
            compile_results[fname] = False

    # Clean up: remove everything except .c
    for fname in os.listdir(c_dir):
        if not fname.endswith('.c'):
            os.remove(os.path.join(c_dir, fname))

    return compile_results


def main():
    print("[main] Starting analysis pipeline")
    result_files = [fn for fn in os.listdir(RESULTS_DIR) if fn.endswith('_results.json')]
    for fn in result_files:
        model = fn[:-len('_results.json')]
        print(f"[main] === Model: {model} ===")
        json_path = os.path.join(RESULTS_DIR, fn)
        c_out_dir = os.path.join(EXTRACT_DIR, model)

        # extract code and get prompts map
        prompts_map = extract_c_files(json_path, c_out_dir)

        # compile‐check the .c files, clean up all other artifacts
        print(f"[compile] Checking compilability in {c_out_dir}")
        comp_results = compile_c_files(c_out_dir)
        succ = sum(1 for ok in comp_results.values() if ok)
        fail = len(comp_results) - succ
        print(f"[compile] {succ}/{len(comp_results)} files compiled successfully, {fail} failed")

        # analyze and include detailed vulnerability and prompt info
        # analyze_with_esbmc(model, c_out_dir, prompts_map)
    print("[main] All analyses complete")

if __name__ == '__main__':
    main()
